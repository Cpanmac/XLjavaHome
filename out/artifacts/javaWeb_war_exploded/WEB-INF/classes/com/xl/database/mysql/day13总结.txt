1 Statement和PreparedStatement的特点
  a)对于创建和删除表或数据库，我们可以使用executeUpdate()，该方法返回0，表示未影向表中任何记录
  b)对于创建和删除表或数据库，我们可以使用execute()，该方法返回false，表示创建和删除数据库表
  c)除了select操作返回true之除，其它的操作都返回false
  d)PreparedStatement有发下的特点：      
    >>解决SQL注入问题，在绑定参数时，动态检测
    >>在发送相同结构的SQL时，较Statement效率有所提升
    >>使用？占位符替代真实的绑定值
    >>项目中，优先使用PreparedStatement

*2 Jsp+Servlet+Javabean+Jdbc+Mysql（用户登录）
   总结：
      a)如何在Servlet处理类似的业务逻辑
		doGet/doPost
		private login()
		private register()

      b)学会层与层之间的耦

*3 MySQL数据库分页
  1)为什么要分页？
  2)MySQL数据库中有没有分页的语句？
    select * from user LIMIT 第几条记录号-1,需要显示记录的条数;
  3)为什么返回List不行，需要返回Page类？   
  思考：分页的其它方式
	
*4 存取大对象
  LOB
    a)Character LOB  -> CLOB (Text有四个子类型)[字符]
      存：
	pstmt.setString(1,UUID.randomUUID().toString());
	URL url = Demo1.class.getClassLoader().getResource("cn/itcast/web/jdbc/config/62.txt");
	File file = new File(url.getPath());
	Reader reader = new FileReader(file);
	pstmt.setCharacterStream(2,reader,(int)file.length());

      取：
	Reader reader = rs.getCharacterStream("content");
	Writer writer = new FileWriter("d:\\62.txt");
	int len = 0;
	char[] cuf = new char[1024];
		while( (len=reader.read(cuf))>0 ){
			writer.write(cuf,0,len);
		}
	reader.close();
	writer.close();


      注意：在能完成业务的情况下，尽早关闭连接对象
            关闭连接对象，不能够发送SQL到数据库方，并不是不能读写数据

	
    b)Binary    LOB  -> BLOB (Blob有四个子类型)[字节]
     
     存：
	pstmt.setString(1,UUID.randomUUID().toString());
	URL url = Demo2.class.getClassLoader().getResource("cn/itcast/web/jdbc/config/d1.jpg");
	File file = new File(url.getPath());
	InputStream is = new FileInputStream(file);
	pstmt.setBinaryStream(2,is,(int)file.length());


      取：
	is = rs.getBinaryStream("content");
	os = new FileOutputStream("d:\\d1.jpg");
	int len = 0;
	byte[] buf = new byte[1024];
	while( (len=is.read(buf))>0 ){
		os.write(buf,0,len);
	}


*5 批处理
  1)想发送多条SQL，又要降低与数据库系统的交互，这时使用批处理
  2)Statement对象：适合对不同结构的SQL做批处理操作
  3)PreparedStatement对象：适合对相同结构的SQL做批处理操作
 
       
6 获取数据库主键值
  1)当需要获取刚插入主键信息的时候，需要使用获取主键值方法
  2)关键代码：
	pstmt = conn.prepareStatement(sqlA,Statement.RETURN_GENERATED_KEYS);
	rs = pstmt.getGeneratedKeys();
	if(rs.next()){
		Long temp = (Long) rs.getObject(1);
		pid = temp.intValue();
	}
 	






















 
7 存储过程












